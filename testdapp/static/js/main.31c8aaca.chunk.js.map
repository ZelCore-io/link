{"version":3,"sources":["../../src/index.js","App.js","index.js"],"names":["constructor","a","e","newPublicKey","resolve","reject","Error","window","Promise","method","requestId","jsonrpc","id","params","network","data","display","response","signature","bs58","publicKey","message","transaction","messages","transactions","tx","signatures","s","isObject","isFunction","isString","URL","URLSearchParams","origin","this","_publicKey","toHex","buffer","Array","prototype","map","call","x","toString","slice","join","App","useState","logs","setLogs","addLog","log","clusterApiUrl","providerUrl","setProviderUrl","connection","useMemo","Connection","urlWallet","Wallet","injectedWallet","solana","console","undefined","selectedWallet","setSelectedWallet","setConnected","Transaction","add","SystemProgram","transfer","fromPubkey","toPubkey","lamports","getRecentBlockhash","recentBlockhash","blockhash","feePayer","signTransaction","signed","sendRawTransaction","serialize","confirmTransaction","warn","TextEncoder","encode","sign","useEffect","on","toBase58","connect","disconnect","className","type","value","onChange","target","trim","connected","onClick","i","key","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.31c8aaca.chunk.js","sourcesContent":["import EventEmitter from 'eventemitter3';\r\nimport { PublicKey } from '@solana/web3.js';\r\nimport bs58 from 'bs58';\r\n\r\nexport default class Wallet extends EventEmitter {\r\n  constructor(provider, network) {\r\n    super();\r\n    if (isInjectedProvider(provider)) {\r\n      this._injectedProvider = provider;\r\n    } else if (isString(provider)) {\r\n      this._providerUrl = new URL(provider);\r\n      this._providerUrl.hash = new URLSearchParams({\r\n        origin: window.location.origin,\r\n        network,\r\n      }).toString();\r\n    } else {\r\n      throw new Error(\r\n        'provider parameter must be an injected provider or a URL string.',\r\n      );\r\n    }\r\n    this._network = network;\r\n    this._publicKey = null;\r\n    this._autoApprove = false;\r\n    this._popup = null;\r\n    this._handlerAdded = false;\r\n    this._nextRequestId = 1;\r\n    this._responsePromises = new Map();\r\n  }\r\n\r\n  _handleMessage = (e) => {\r\n    if (\r\n      (this._injectedProvider && e.source === window) ||\r\n      (e.origin === this._providerUrl.origin && e.source === this._popup)\r\n    ) {\r\n      if (e.data.method === 'connected') {\r\n        const newPublicKey = new PublicKey(e.data.params.publicKey);\r\n        if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {\r\n          if (this._publicKey && !this._publicKey.equals(newPublicKey)) {\r\n            this._handleDisconnect();\r\n          }\r\n          this._publicKey = newPublicKey;\r\n          this._autoApprove = !!e.data.params.autoApprove;\r\n          this.emit('connect', this._publicKey);\r\n        }\r\n      } else if (e.data.method === 'disconnected') {\r\n        this._handleDisconnect();\r\n      } else if (e.data.result || e.data.error) {\r\n        if (this._responsePromises.has(e.data.id)) {\r\n          const [resolve, reject] = this._responsePromises.get(e.data.id);\r\n          if (e.data.result) {\r\n            resolve(e.data.result);\r\n          } else {\r\n            reject(new Error(e.data.error));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  _handleConnect = () => {\r\n    if (!this._handlerAdded) {\r\n      this._handlerAdded = true;\r\n      window.addEventListener('message', this._handleMessage);\r\n      window.addEventListener('beforeunload', this.disconnect);\r\n    }\r\n    if (this._injectedProvider) {\r\n      return new Promise((resolve) => {\r\n        this._sendRequest('connect', {});\r\n        resolve();\r\n      });\r\n    } else {\r\n      window.name = 'parent';\r\n      this._popup = window.open(\r\n        this._providerUrl.toString(),\r\n        '_blank',\r\n        'location,resizable,width=460,height=675',\r\n      );\r\n      return new Promise((resolve) => {\r\n        this.once('connect', resolve);\r\n      });\r\n    }\r\n  };\r\n\r\n  _handleDisconnect = () => {\r\n    if (this._handlerAdded) {\r\n      this._handlerAdded = false;\r\n      window.removeEventListener('message', this._handleMessage);\r\n      window.removeEventListener('beforeunload', this.disconnect);\r\n    }\r\n    if (this._publicKey) {\r\n      this._publicKey = null;\r\n      this.emit('disconnect');\r\n    }\r\n    this._responsePromises.forEach(([resolve, reject], id) => {\r\n      this._responsePromises.delete(id);\r\n      reject('Wallet disconnected');\r\n    });\r\n  };\r\n\r\n  _sendRequest = async (method, params) => {\r\n    if (method !== 'connect' && !this.connected) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n    const requestId = this._nextRequestId;\r\n    ++this._nextRequestId;\r\n    return new Promise((resolve, reject) => {\r\n      this._responsePromises.set(requestId, [resolve, reject]);\r\n      if (this._injectedProvider) {\r\n        this._injectedProvider.postMessage({\r\n          jsonrpc: '2.0',\r\n          id: requestId,\r\n          method,\r\n          params: {\r\n            network: this._network,\r\n            ...params,\r\n          },\r\n        });\r\n      } else {\r\n        this._popup.postMessage(\r\n          {\r\n            jsonrpc: '2.0',\r\n            id: requestId,\r\n            method,\r\n            params,\r\n          },\r\n          this._providerUrl.origin,\r\n        );\r\n\r\n        if (!this.autoApprove) {\r\n          this._popup.focus();\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  get publicKey() {\r\n    return this._publicKey;\r\n  }\r\n\r\n  get connected() {\r\n    return this._publicKey !== null;\r\n  }\r\n\r\n  get autoApprove() {\r\n    return this._autoApprove;\r\n  }\r\n\r\n  connect = () => {\r\n    if (this._popup) {\r\n      this._popup.close();\r\n    }\r\n    return this._handleConnect();\r\n  };\r\n\r\n  disconnect = async () => {\r\n    if (this._injectedProvider) {\r\n      await this._sendRequest('disconnect', {});\r\n    }\r\n    if (this._popup) {\r\n      this._popup.close();\r\n    }\r\n    this._handleDisconnect();\r\n  };\r\n\r\n  sign = async (data, display) => {\r\n    if (!(data instanceof Uint8Array)) {\r\n      throw new Error('Data must be an instance of Uint8Array');\r\n    }\r\n\r\n    const response = await this._sendRequest('sign', {\r\n      data,\r\n      display,\r\n    });\r\n    const signature = bs58.decode(response.signature);\r\n    const publicKey = new PublicKey(response.publicKey);\r\n    return {\r\n      signature,\r\n      publicKey,\r\n    };\r\n  };\r\n\r\n  signTransaction = async (transaction) => {\r\n    const response = await this._sendRequest('signTransaction', {\r\n      message: bs58.encode(transaction.serializeMessage()),\r\n    });\r\n    const signature = bs58.decode(response.signature);\r\n    const publicKey = new PublicKey(response.publicKey);\r\n    transaction.addSignature(publicKey, signature);\r\n    return transaction;\r\n  };\r\n\r\n  signAllTransactions = async (transactions) => {\r\n    const response = await this._sendRequest('signAllTransactions', {\r\n      messages: transactions.map((tx) => bs58.encode(tx.serializeMessage())),\r\n    });\r\n    const signatures = response.signatures.map((s) => bs58.decode(s));\r\n    const publicKey = new PublicKey(response.publicKey);\r\n    transactions = transactions.map((tx, idx) => {\r\n      tx.addSignature(publicKey, signatures[idx]);\r\n      return tx;\r\n    });\r\n    return transactions;\r\n  };\r\n}\r\n\r\nfunction isString(a) {\r\n  return typeof a === 'string';\r\n}\r\n\r\nfunction isInjectedProvider(a) {\r\n  return isObject(a) && isFunction(a.postMessage);\r\n}\r\n\r\nfunction isObject(a) {\r\n  return typeof a === 'object' && a !== null;\r\n}\r\n\r\nfunction isFunction(a) {\r\n  return typeof a === 'function';\r\n}\r\n","import React, { useEffect, useMemo, useState } from 'react';\r\nimport './App.css';\r\nimport Wallet from '@project-serum/sol-wallet-adapter';\r\nimport { Connection, SystemProgram, Transaction, clusterApiUrl } from '@solana/web3.js';\r\n\r\nfunction toHex(buffer) {\r\n  return Array.prototype.map\r\n    .call(buffer, (x) => ('00' + x.toString(16)).slice(-2))\r\n    .join('');\r\n}\r\n\r\nfunction App() {\r\n  const [logs, setLogs] = useState([]);\r\n  function addLog(log) {\r\n    setLogs((logs) => [...logs, log]);\r\n  }\r\n\r\n  const network = clusterApiUrl('devnet');\r\n  const [providerUrl, setProviderUrl] = useState('https://link.zelcore.io');\r\n  const connection = useMemo(() => new Connection(network), [network]);\r\n  const urlWallet = useMemo(() => new Wallet(providerUrl, network), [\r\n    providerUrl,\r\n    network,\r\n  ]);\r\n  const injectedWallet = useMemo(() => {\r\n    try {\r\n      return new Wallet(window.solana, network);\r\n    } catch (e) {\r\n      console.log(`Could not create injected wallet: ${e}`);\r\n      return null;\r\n    }\r\n  }, [network]);\r\n  const [selectedWallet, setSelectedWallet] = useState(undefined);\r\n  const [, setConnected] = useState(false);\r\n  useEffect(() => {\r\n    if (selectedWallet) {\r\n      selectedWallet.on('connect', () => {\r\n        setConnected(true);\r\n        addLog('Connected to wallet ' + selectedWallet.publicKey.toBase58());\r\n      });\r\n      selectedWallet.on('disconnect', () => {\r\n        setConnected(false);\r\n        addLog('Disconnected from wallet');\r\n      });\r\n      selectedWallet.connect();\r\n      return () => {\r\n        selectedWallet.disconnect();\r\n      };\r\n    }\r\n  }, [selectedWallet]);\r\n\r\n  async function sendTransaction() {\r\n    try {\r\n      let transaction = new Transaction().add(\r\n        SystemProgram.transfer({\r\n          fromPubkey: selectedWallet.publicKey,\r\n          toPubkey: selectedWallet.publicKey,\r\n          lamports: 100,\r\n        })\r\n      );\r\n      addLog('Getting recent blockhash');\r\n      transaction.recentBlockhash = (\r\n        await connection.getRecentBlockhash()\r\n      ).blockhash;\r\n      addLog('Sending signature request to wallet');\r\n      transaction.feePayer = selectedWallet.publicKey;\r\n      let signed = await selectedWallet.signTransaction(transaction);\r\n      addLog('Got signature, submitting transaction');\r\n      let signature = await connection.sendRawTransaction(signed.serialize());\r\n      addLog('Submitted transaction ' + signature + ', awaiting confirmation');\r\n      await connection.confirmTransaction(signature, 'singleGossip');\r\n      addLog('Transaction ' + signature + ' confirmed');\r\n    } catch (e) {\r\n      console.warn(e);\r\n      addLog('Error: ' + e.message);\r\n    }\r\n  }\r\n\r\n  async function signMessage() {\r\n    try {\r\n      const message = \"Please sign this message for proof of address ownership.\";\r\n      addLog('Sending message signature request to wallet');\r\n      const data = new TextEncoder().encode(message);\r\n      const signed = await selectedWallet.sign(data, 'hex');\r\n      addLog('Got signature: ' + toHex(signed.signature));\r\n    } catch (e) {\r\n      console.warn(e);\r\n      addLog('Error: ' + e.message);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>Wallet Adapter Demo</h1>\r\n      <div>Network: {network}</div>\r\n      <div>\r\n        Waller provider:{' '}\r\n        <input\r\n          type=\"text\"\r\n          value={providerUrl}\r\n          onChange={(e) => setProviderUrl(e.target.value.trim())}\r\n        />\r\n      </div>\r\n      {selectedWallet && selectedWallet.connected ? (\r\n        <div>\r\n          <div>Wallet address: {selectedWallet.publicKey.toBase58()}.</div>\r\n          <button onClick={sendTransaction}>Send Transaction</button>\r\n          <button onClick={signMessage}>Sign Message</button>\r\n          <button onClick={() => selectedWallet.disconnect()}>Disconnect</button>\r\n        </div>\r\n      ) : (\r\n        <div>\r\n          <button onClick={() => setSelectedWallet(urlWallet)}>Connect to Wallet</button>\r\n          <button onClick={() => setSelectedWallet(injectedWallet)}>Connect to Injected Wallet</button>\r\n        </div>\r\n      )}\r\n      <hr />\r\n      <div className=\"logs\">\r\n        {logs.map((log, i) => (\r\n          <div key={i}>{log}</div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import './index.css';\r\n\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}